Содержание
1. HTML API
2. History states
3. Local/session storage
4. FileAPI
5. WebSocket
6. WebWorker
7. Geolocation

<h1>HTML API</h1>
<p>
  <strong>Это еще один вид API, расширяющий BOM(Browser Object Model)</strong>
</p>

<p>
  В современном мире, браузер уже давно перестал быть обычным средством просмотра страниц.
</p>

<p>
  Помимо серфинга страниц, современные браузеры имеют гораздо больший арсенал возможностей: определению местонахождения пользователя, встроенные средства для организации конференц-связи, работа с виртуальной файловой системой, работа со встроенной РБД (реляционная база данных), прямой доступ к видео и звуковой карте вашей системы, и еще огромное количество различных других улучшений, которые делают из вашего браузера многофункциональный программный комплекс.
</p>

<p>
  И естественно, что вы можете использовать эти возможности в своих JS-скриптах.
</p>
<p>
  Ниже перечислены самые популярные составляющие <strong>HTML5 API</strong>.
</p>

<h2>History states</h2>

<p>
  <em>Это механизм, позволяющий создавать цепочку состояний страницы и затем перемещаться по этой цепочке в обоих направлениях при помощи кнопок навигации вперед и назад, восстанавливая данные состояния.</em>
</p>

<p>
  Отличительная особенность заключается в том, что никакой перезагрузки страницы, при использовании кнопок навигации, не происходит. Данный механизм широко используется в <strong>SPA(Single Page Application)</strong>.
</p>

<p>
  Вот так просто можно попросить браузер добавить новое состояние в цепочку.
</p>

```js
history.pushState({
  prop1: 'value1',
  prop2: 'value2',
}, 'state name', '/some/url');
```
<p>
  Браузер создаст новое состояние с именем <strong>state name</strong>, присвоит этом состоянию адрес <strong>/some/url</strong> и запишет в него переданный объект.
</p>

<p>
  Собрав таким образом цепочку состояний, мы можем перемещаться по ней  при помощи кнопок навигации.
</p>

<p>
  При этом, мы сможем наблюдать, как в адресной строке меняется URL на указанный при добавлении текущего состояния, но перезагрузки страницы при этом не происходит. Таким образом, мы эмитируем переход по страницам, но на самом деле происходит переход по запомненным ранее состояниям.
</p>
<p>
  А вот так можно отловить тот момент, когда происходит смена состояния:
</p>
```js
window.addEventListener('popstate', function(e) {
  console.log(e.state);
});
```
<p>
  И именно в этом обработчике мы будем принимать решение, что сделать с данными, сохраненными в состоянии. Например, мы можем восстановить содержимое текстовых полей сохраненными значениями.
</p>

<h2>Local/session storage</h2>

<p>
  <em>Это механизмы, позволяющие хранить данные внутри браузера.</em>
</p>
<p>
  Сразу может возникнуть вопрос: “А зачем? Ведь есть cookies!”
</p>
<p>Всё очень просто:</p>
<p><strong>Cookies</strong> текущей страницы автоматически отправляются при каждом запросе на сервер. Данные из <strong>local storage</strong> никуда не отправляются.
</p>
<p>
  <strong>Cookeis</strong> имеют ограничение на размер хранимых данных в несколько килобайт. <strong>Local storage</strong> имеет гораздо большую вместимость - несколько мегабайт (конкретное число зависит от браузера).
</p>
<p>
  <strong>Cookies</strong> имеют ограниченное время жизни. Данные в <strong>local storage</strong> не имеют ограничения во времени жизни.
</p>
<p>
  Плюс ко всему, отличается и сами механизм работы с ним из JS. <strong>Local storage</strong> - это сего лишь объект. И вот как можно с ним работать:
</p>
```js
localStorage.someData = 'привет!';
console.log(localStorage.someData); //выведет "привет"
```
<p>
  Гораздо проще, чем с cookies, не правда ли?
</p>
<p>
  Данные в <strong>local storage</strong> не потеряются, даже если вы закроете браузер.
</p>
<p>
  В <strong>local storage</strong> можно хранить только строки.
</p>
<p>
  Таким образом, если вы хотите хранить объект или массив, то необходимо превратить их в строку, а при чтении из local storage - превратить обратно:
</p>
```js
var data = {
  prop1: 'привет',
  prop2: 'school'
};

localStorage.someData = JSON.stringify(data);

data = JSON.parse(localStorage.someData);
console.log(data); // выведет в консоль объект
```
<p>
  Для <strong>session storage</strong> применимо всё то, что мы описали для <strong>local storage</strong> за тем лишь исключением, что данные в
  <strong>session storage</strong> сотрутся сразу после закрытия браузера.
</p>

<h2>FileAPI</h2>

<p>
  <em>Механизм, позволяющий получить содержимое выбранных пользователем файлов в режиме реального времени,</em> что дает возможность, например, посмотреть загружаемый файл в браузере еще до его загрузки на сервер. Так же, есть возможность разделить загружаемый файл на части, прямо в браузере и загрузить его на сервер по частям. Всё это делается при помощи специального объекта - <strong>FileReader</strong>.
</p>
<p>
  Именно через <strong>FileReader</strong> мы можем преобразовать файл, указанный пользователем в набор байт или текст и отобразить в браузере.
</p>
<p>
  Тема <strong>FileAPI</strong> довольно обширна и на этот счет в интернете есть замечательная статья с примерам - <a href="http://www.html5rocks.com/ru/tutorials/file/dndfiles/">FileAPI</a>
</p>

<h2>WebSocket</h2>
<p>
  <em>Механизм, позволяющий поддерживать с сервером постоянное соединение.</em>
</p>
<p>
  Как известно, протокол http устроен таким образом, что передав запрошенное содержимое, сервер разрывает соединение с браузером.
</p>
<p>
  Но с приходом <strong>WebSocket</strong>, стало возможным поддерживать постоянное соединение браузера с сервером, даже после окончания передачи данных от сервера к браузеру.
</p>
<p>
  Таким образом, создание чата, работающего без перезагрузки страницы - больше не является чем-то фантастическим.
</p>
<p>
  Для начала, необходимо убедиться, что сервер, к которому мы собираемся  подключиться, поддерживает <strong>WebSocket</strong>.
</p>
<p>
  Если поддерживает, то необходимо создать <strong>socket</strong>:
</p>
```js
var socket = new WebSocket("ws://localhost:8080");
```
<p>
  Как видите, мы подключаемся по протоколу <strong>ws:// к серверу с именем localhost и портом 8080</strong>.
</p>
<p>
  После этого, созданному сокету необходимо добавить обработчик события <strong>message</strong> чтобы иметь возможность получать сообщения от сервера:
</p>
```js
socket.onmessage = function(event) {
  console.log(event.data);
}
```
<p>
  Отправлять сообщения на сервер можно при помощи метода <strong>send()</strong>:
</p>
```js
socket.send('привет!');
```

<h2>WebWorker</h2>
<p>
  <em>Это механизм, позволяющий запускать какой-либо код параллельно с основным кодом.</em>
</p>
<p>
  Это может быть полезно в тех случаях, когда необходимо реализовать обработку каких-либо больших массивов данных, а нагружать основной поток кода не хочется.
</p>
<p>
  Работать с воркером очень просто. Для начала, его необходимо создать:
</p>
```js
var worker = new Worker('worker.js');
```
<p>
  При создании воркера, необходимо указать скрипт, в котором содержится исходный код самого воркера. Это самый обычный JS-скрипт, с обработчиком глобального события <strong>message</strong>:
</p>

```js
//это код внутри воркера
self.addEventListener('message', function(e) {
  //какие-то операции
});
```
<p>
  Это нужно только в том случае, если необходимо, чтобы воркер принимал
  сообщения от основного потока.
</p>
<p>
  Основной поток, в свою очередь, тоже может принимать сообщения от воркера, для этого, в основном коде, необходимо добавить обработчик события <strong>message</strong> воркера:
</p>

```js
//это код внутри основного файла
worker.addEventListener('message', function(e) {
  console.log(event.data);
};
```

<p>
  Всё, что умеет воркер - это обмениваться сообщениями с основным кодом и производить затратные вычисления:
</p>

```js
//это код внутри воркера
self.postMessage('привет!');

//это код внутри основного файла
worker.postMessage('привет!');
```
<p>
  Заметьте, что внутри вокрера, у вас нет доступа к dom-дереву! Воркер не предназначен для работы с DOM.
</p>

<h2>Geolocation</h2>
<p>
  <em>Механизм, позволяющий получить координаты своего местонахождения.</em>
</p>
<p>
  Несмотря на кажущуюся сложность, использовать этот механизм очень просто:
</p>

```js
navigator.geolocation.getCurrentPosition(function(geo) {
  console.log(geo);
});
```
<p>
  Вот и всё! Вызываем метод <strong>getCurrentPosition()</strong> и передаем ему <strong>callback-функцию</strong>, которая будет вызвана сразу после того, когда браузера определит наше местонахождения. В функцию автоматически будет передана информация о нашем местонахождении.
</p>
<p>
  Так же есть возможность отслеживать перемещение владельца браузера:
</p>
```js
var watchId = navigator.geolocation.watchPosition(function(geo){
  console.log(geo);
});
```
<p>
  Смысл тот же самый, за тем лишь исключением, что <strong>callback</strong>, переданный в <strong>watchPosition</strong>, будет вызван не один раз, а будет вызываться бесконечно, с определенной периодичностью.
</p>
<p>
  <strong>watchPosition</strong> возвращает идентификатор, который может быт использован для отмены отслеживания:
</p>
```js
navigator.geolocation.clearWatch(watchId);
```
