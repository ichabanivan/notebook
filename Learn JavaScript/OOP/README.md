<h1>ООП</h1>
<h2>this</h2>
<p>Создадим два объекта.</p>
```js
var a = {
  prop: 1,
  f: function() {
    console.log(this.prop);
  }
},
b = {
  prop: 2,
  f: function() {
   console.log(this.prop);
  }
};
```
<p>
  Если мы вызовем функцию <strong>f()</strong> у каждого из объектов, мы увидим чему равно значение свойства prop у каждого из объектов:
</p>
<ul>
  <li><strong>a.f();</strong></li>
  <li><strong>b.f();</strong></li>
</ul>

<p>Теперь более подробно поговорим про <strong>this</strong>. Бытует утверждение, что this указывает на объект, из которого вызывается текущая функция. Это мнение является в корне неверным. <em>this указывает на объект, в контексте которого вызывается   функция.</em>
</p>

<p>
  Разница в том, что контекст функции мы можем менять. То есть вызывая функцию <strong>f()</strong> из объекта A, мы можем сделать так, чтобы <strong>this</strong>, внутри этой функции, указывал на объект B. Когда мы вызываем функцию из объекта, контекст этой функции равен тому объекту, из которого мы эту функцию вызываем. Но у каждой функции в JS есть три вспомогательные функции, которые позволяют менять контекст этой функции. Немного запутанно звучит, но на самом деле всё становится понятно, если представить функцию как самый обычный объект, коим функция и является. Так вот у этого объекта есть три метода: <strong>bind</strong>, <strong>call</strong> и <strong>apply</strong>. Эти методы позволяют менять контекст у функции. Пользоваться ими чрезвычайно просто.
</p>

<h2>Смена контекста</h2>
<h3>bind</h3>
<p>
  Bind меняет контекст функции на указанный и возвращает новую функцию, с уже измененным контекстом. Не вызывает указанную функцию, а возвращает новую функцию, с измененным контекстом!
</p>
<p>
  Вот как это работает. Для начала просто сохраним функцию из объекта в переменную
</p>
```js
var newFunc = a.f;
```
<p>Заметьте, мы не вызываем функцию, а просто сохраняем ее в переменную. Это важно.</p>
<p>Теперь вызовем то, что мы только что сохранили.</p>
```js
newFunc(); //выведется undefined
```
<p>
  Всё потому, что функция потеряла свой контекст и теперь <strong>this</strong>, внутри этой функции указывает не на объект A, а на нечто другое, о чем будет рассказано позже.
</p>
<p>
  Но стоит так же отметить, что в переменной newFunc и в объекте A одна и та же функция.
</p>
<p>
  Просто если вызывать ее из объекта А, то контекстом ее является объект А, а если вызывать ее просто, как отдельную часть, то контекста нет. Точнее он есть, но об этом позже.
</p>
<p>Вернемся к функции <strong>bind</strong> и применим ее.</p>
<p>Напомню, что bind возвращает новую функцию с указанным контекстом.</p>
<p>В переменную newFunc запишем результат функции <strong>bind()</strong></p>
```js
var newFunc = a.f.bind(a);
```
<p>Теперь вызовем то, что получилось.</p>
```js
newFunc();
```
<p>
  Как видите, теперь, даже вызывая функцию без объекта, this внутри этой функции указывает на объект, который мы указали при использовании bind.
</p>
<p>
  Еще более интересный пример: заменим функцию f в объекте A на ту же функцию, но с другим контекстом.
</p>
```js
a.f = a.f.bind(b);

a.f();
b.f();
```

<p>
  Теперь в обоих случаях выводится цифра два. Всё потому, что в первом случае мы заменили контекст на объект B, а во втором, сохранился родной контекст.
</p>
<p>Может возникнуть вопрос: а почему бы просто не сделать так:</p>
```js
a.f = b.f;
```
<p>
  То есть подменить функцию f в объекте A, той же самой функцией, но уже из объекта B, в надежде на то, что this этой функции тоже переедет из объекта в объект.
</p>
<p>
  Тут важно понимать, что мы всего лишь заменили функцию, но как только мы будем вызывать эту функцию из объекта, контекстом этой функции станет тот объект, из которого мы эту функцию вызываем. Но функции для смены контекста позволяют это обойти, ведь применив метод bind, мы можем заменить контекст таким образом, чтобы не имело значения из какого объекта мы вызываем функцию.
</p>
<p>Так же замечу, что изменить контекст мы можем всего один раз. Вот пример:</p>
```js
var newFunc = a.f.bind(b);
newFunc = newFunc.bind(a);
newFunc();
```
<p>
  Как видим, вторая привязка контекста не сработала.
</p>
<p>
  Это не значит, что у нас есть какие-то ограничения по количеству привязок контекста, это всего лишь значит, что у функции, которая получается в результате bind, мы больше не можем менять контекст.
</p>
<p>
  <strong>this</strong> внутри функции - это ее контекст, а не объект из которого мы эту функцию вызываем.
</p>
<p>
  Кстати, в IE, bind доступна начиная с 9 версии. В более ранних версиях, метод bind эмулировался программно.
</p>

<h3>call</h3>
<p>
  Работают они по такому же принципу, как и <strong>bind</strong>, то есть меняют контекст функции, но если <strong>bind</strong> не вызывает функцию с новым контекстом, а просто возвращает ее, то <strong>call</strong> и <strong>apply</strong>, помимо смены контекста, еще и вызывают новую функцию и возвращают то, что возвратила бы эта функция. Но чем же тогда strong>call</strong> и <strong>apply</strong> различаются между собой?
</p>
<p>
  Приведу очень грубый, но наглядный пример. Предположим, что функция f принимает два аргумента, два числа. Цель этой функции сложить эти два числа с полем prop:
</p>
```js
var a = {
  prop: 1,
  f: function (a, b) {
    console.log(this.prop + a + b);
  }
},
b = {
  prop: 2,
  f: function (a, b) {
    console.log(this.prop + a + b);
  }
};
```
<p>
  На самом деле, мы можем вообще вынести эту функцию за объекты, чтобы не дублировать ее, а в свойствах объектов просто прописать ссылку на нее.
</p>
```js
var summ = function(a, b) {
      console.log(this.prop + a + b);
    },
    a = {
      prop: 1,
      f: summ
    },
    b = {
      prop: 2,
      f: summ
    };

a.f(1, 1);
b.f(2, 2);
```
<p>
  Как видите, при вызове функций, контекст подставляется динамически и поэтому мы наблюдаем довольно предсказуемое поведение.
</p>
<p>
  Теперь применим метод <strong>call</strong>, но для наглядности, уже к функции summ:
</p>
```js
summ.call(a, 1, 1);
summ.call(b, 2, 2);
```
<p>
  Первым параметром передается контекст, в котором будет выполняться функция, а остальные переданные аргументы передадутся функции. Таким образом, второй аргумент call станет первым аргументом функции и так далее.
</p>
<p>
  Теперь изменим функцию так, чтобы она не выводила в консоль результат, а возвращала его.
</p>
```js
var summ = function(a, b) {
  return this.prop + a + b;
}
```
<p>
  Теперь <strong>summ.call</strong> будет возвращать результат, который мы можем вывести.
</p>
```js
console.log(summ.call(a, 1, 1));
console.log(summ.call(b, 2, 2));
```
<p>Это наглядно демонстрирует работу <strong>call</strong>.</p>

<h3>apply</h3>
<p>
  Она работает точно так же как и <strong>call</strong>, разница только в передаче аргументов в функцию.
</p>
<p>
  Если в <strong>call</strong> мы передавали аргументы напрямую, то в <strong>apply</strong> нужно передавать всего лишь массив с аргументами, а <strong>apply</strong> сама развернет этот массив и передаст аргументы в функцию в нужном порядке.
</p>
```js
console.log(summ.apply(a, [1, 1]));
console.log(summ.apply(b, [2, 2]));
```
<p>
  Как видите, результат не изменился. В <strong>apply</strong> мы передали аргументы для функции в виде массива, а <strong>apply</strong> сама подставила элементы из массива на нужные позиции. Так, первый элемент массива стал первым аргументом функции и тд.
</p>

<p>Теперь выясним чему равен контекст функции, если не вызывать ее из объекта и не применять к ней <strong>bind</strong>, <strong>call</strong> или <strong>apply</strong>.</p>

<h2>Контекст по умолчанию</h2>
<p>Вызовем функцию summ в самом обычном виде</p>
```js
summ(1,1);
```
<p>а внутри функции выведем в консоль this</p>
```js
console.log(this);
```
<p>и запустим скрипт в браузере, для большей наглядности.</p>
<p>Итак, если функции явно не указать контекст, то по умолчанию он равен глобальному объекту. Если запускать скрипт в браузере, то там глобальный объект всегда равен <strong>window</strong>.</p>
<p>Теперь нужно запомнить вот что:</p>
<p><strong>Контекст у функции может быть всего лишь в трех случаях:</strong></p>
<ul>
  <li>
    либо когда мы вызываем функцию из объекта (через точку или квадратные скобки)
  </li>
  <li>
    либо когда используем <strong>bind</strong>, <strong>call</strong> или <strong>apply</strong>
  </li>
  <li>
    или если при вызове функции использовать ключевое слово <strong>new</strong> (разберем позднее)<
    /li>
</ul>
<p>Во всех остальных случаях контекст будет сброшен на глобальный объект.</p>
<p>Вот пример, с которым у разработчиков очень часто возникают затруднения:</p>
```js
var a = {
  prop: 1,
  f: function() {
      var func = function() {
        console.log(this.prop)
      };
      func();
  }
};

a.f();
```

<p>
  Внутри функции f контекст, ясное дело, будет указывать на объект A, а какой будет контекст у функции func?
</p>
<p>
  Вспомним то правило, о котором было сказано ранее:
</p>

<p><strong>Контекст у функции может быть всего лишь в трех случаях:</strong></p>
<ul>
  <li>
    либо когда мы вызываем функцию из объекта (через точку или квадратные скобки)
  </li>
  <li>
    либо когда используем <strong>bind</strong>, <strong>call</strong> или <strong>apply</strong>
  </li>
  <li>
    или если при вызове функции использовать ключевое слово <strong>new</strong> (разберем позднее)<
    /li>
</ul>

<p>
  Функцию func мы вызываем как есть. Не из объекта и не используем <strong>bind</strong>, <strong>call</strong> или <strong>apply</strong>. Следовательно у нее нет контекста, а следовательно <strong>this</strong> будет указывать на <strong>window</strong>, поэтому если мы сейчас запустим скрипт, то увидим <strong>undefined</strong>.
</p>

<p>Почему же с этим примером часто возникает недопонимание?</p>
<p>
  Дело в том, что многие думают, что раз уж мы запускаем функцию из функции, которая имеет контекст, то у этой внутренней функции тоже будет контекст… как бы не так! Сразу вспоминаем то правило!
</p>
<p>
  Решается такая задача очень просто, если вам необходимо передать контекст от основной функции во внутреннюю, то вы либо используете bind, call или apply либо сохраняете контекст в переменную и потом эту переменную используете во внутренней функции
</p>
<p>Разберем оба варианта.</p>
```js
func.call(this);
```
<p>Здесь мы просто, так сказать, пробросили контекст во внутреннюю функцию, думаю здесь не нужно больше пояснений.</p>
<p>И второй вариант:</p>
```js
var that = this;

var func = function () {
  console.log(that.prop)
};

func();
```
<p>Здесь мы просто сохранили текущий контекст функции в переменную и использовали эту переменную внутри вложенной функции.</p>
<p>
  О данном подходе еще иногда говорят - передали контекст через замыкание.
</p>
<p>
  Кстати, если вы используете строгий режим, то контекст по умолчанию будет равер undefined.
</p>
<p>Ну вот мы и разобрались с контекстом.</p>
<p>Осталось рассказать про одну маленькую особенность метода bind.</p>
<h2>bind и аргументы</h2>
<p>
  Если при вызове метода <strong>bind</strong>, передать ему дополнительные аргументы, как в случае с <strong>call</strong>, то <strong>bind</strong> запомнит эти аргументы и при вызове получившейся функции - будет подставлять эти аргументы. Вот так это выглядит:
</p>
```js
var summ = function(a, b) {
  return this.prop + a + b;
};
var newFunc = summ.bind(a, 1, 1);
console.log(newFunc());
```
<p>
  Как видите, мы вызвали новую функцию вообще без параметров. Параметры подставились автоматически, т.к. <strong>bind</strong> запомнил те значения, которые мы ему передали.
</p>


