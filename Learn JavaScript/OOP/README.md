<h1>ООП</h1>
```js
let a = [
  (1).constructor,  // Number
  true.constructor, // Boolean
  [].constructor,   // Array
  "".constructor,   // String
  (function () {}).constructor, // Function
  {}.constructor,    // Object
  (/./).constructor, // RegExp
  NaN.constructor    // Number
];

console.log(null instanceof Object) // false
typeof null // "object"
```
<h2>this</h2>
<p>Создадим два объекта.</p>
```js
var a = {
  prop: 1,
  f: function() {
    console.log(this.prop);
  }
},
b = {
  prop: 2,
  f: function() {
   console.log(this.prop);
  }
};
```
<p>
  Если мы вызовем функцию <strong>f()</strong> у каждого из объектов, мы увидим чему равно значение свойства prop у каждого из объектов:
</p>
<ul>
  <li><strong>a.f();</strong></li>
  <li><strong>b.f();</strong></li>
</ul>

<p>Теперь более подробно поговорим про <strong>this</strong>. Бытует утверждение, что this указывает на объект, из которого вызывается текущая функция. Это мнение является в корне неверным. <em>this указывает на объект, в контексте которого вызывается   функция.</em>
</p>

<p>
  Разница в том, что контекст функции мы можем менять. То есть вызывая функцию <strong>f()</strong> из объекта A, мы можем сделать так, чтобы <strong>this</strong>, внутри этой функции, указывал на объект B. Когда мы вызываем функцию из объекта, контекст этой функции равен тому объекту, из которого мы эту функцию вызываем. Но у каждой функции в JS есть три вспомогательные функции, которые позволяют менять контекст этой функции. Немного запутанно звучит, но на самом деле всё становится понятно, если представить функцию как самый обычный объект, коим функция и является. Так вот у этого объекта есть три метода: <strong>bind</strong>, <strong>call</strong> и <strong>apply</strong>. Эти методы позволяют менять контекст у функции. Пользоваться ими чрезвычайно просто.
</p>

<h2>Смена контекста</h2>
<h3>bind</h3>
<p>
  Bind меняет контекст функции на указанный и возвращает новую функцию, с уже измененным контекстом. Не вызывает указанную функцию, а возвращает новую функцию, с измененным контекстом!
</p>
<p>
  Вот как это работает. Для начала просто сохраним функцию из объекта в переменную
</p>
```js
var newFunc = a.f;
```
<p>Заметьте, мы не вызываем функцию, а просто сохраняем ее в переменную. Это важно.</p>
<p>Теперь вызовем то, что мы только что сохранили.</p>
```js
newFunc(); //выведется undefined
```
<p>
  Всё потому, что функция потеряла свой контекст и теперь <strong>this</strong>, внутри этой функции указывает не на объект A, а на нечто другое, о чем будет рассказано позже.
</p>
<p>
  Но стоит так же отметить, что в переменной newFunc и в объекте A одна и та же функция.
</p>
<p>
  Просто если вызывать ее из объекта А, то контекстом ее является объект А, а если вызывать ее просто, как отдельную часть, то контекста нет. Точнее он есть, но об этом позже.
</p>
<p>Вернемся к функции <strong>bind</strong> и применим ее.</p>
<p>Напомню, что bind возвращает новую функцию с указанным контекстом.</p>
<p>В переменную newFunc запишем результат функции <strong>bind()</strong></p>
```js
var newFunc = a.f.bind(a);
```
<p>Теперь вызовем то, что получилось.</p>
```js
newFunc();
```
<p>
  Как видите, теперь, даже вызывая функцию без объекта, this внутри этой функции указывает на объект, который мы указали при использовании bind.
</p>
<p>
  Еще более интересный пример: заменим функцию f в объекте A на ту же функцию, но с другим контекстом.
</p>
```js
a.f = a.f.bind(b);

a.f();
b.f();
```

<p>
  Теперь в обоих случаях выводится цифра два. Всё потому, что в первом случае мы заменили контекст на объект B, а во втором, сохранился родной контекст.
</p>
<p>Может возникнуть вопрос: а почему бы просто не сделать так:</p>
```js
a.f = b.f;
```
<p>
  То есть подменить функцию f в объекте A, той же самой функцией, но уже из объекта B, в надежде на то, что this этой функции тоже переедет из объекта в объект.
</p>
<p>
  Тут важно понимать, что мы всего лишь заменили функцию, но как только мы будем вызывать эту функцию из объекта, контекстом этой функции станет тот объект, из которого мы эту функцию вызываем. Но функции для смены контекста позволяют это обойти, ведь применив метод bind, мы можем заменить контекст таким образом, чтобы не имело значения из какого объекта мы вызываем функцию.
</p>
<p>Так же замечу, что изменить контекст мы можем всего один раз. Вот пример:</p>
```js
var newFunc = a.f.bind(b);
newFunc = newFunc.bind(a);
newFunc();
```
<p>
  Как видим, вторая привязка контекста не сработала.
</p>
<p>
  Это не значит, что у нас есть какие-то ограничения по количеству привязок контекста, это всего лишь значит, что у функции, которая получается в результате bind, мы больше не можем менять контекст.
</p>
<p>
  <strong>this</strong> внутри функции - это ее контекст, а не объект из которого мы эту функцию вызываем.
</p>
<p>
  Кстати, в IE, bind доступна начиная с 9 версии. В более ранних версиях, метод bind эмулировался программно.
</p>

<h3>call</h3>
<p>
  Работают они по такому же принципу, как и <strong>bind</strong>, то есть меняют контекст функции, но если <strong>bind</strong> не вызывает функцию с новым контекстом, а просто возвращает ее, то <strong>call</strong> и <strong>apply</strong>, помимо смены контекста, еще и вызывают новую функцию и возвращают то, что возвратила бы эта функция. Но чем же тогда strong>call</strong> и <strong>apply</strong> различаются между собой?
</p>
<p>
  Приведу очень грубый, но наглядный пример. Предположим, что функция f принимает два аргумента, два числа. Цель этой функции сложить эти два числа с полем prop:
</p>
```js
var a = {
  prop: 1,
  f: function (a, b) {
    console.log(this.prop + a + b);
  }
},
b = {
  prop: 2,
  f: function (a, b) {
    console.log(this.prop + a + b);
  }
};
```
<p>
  На самом деле, мы можем вообще вынести эту функцию за объекты, чтобы не дублировать ее, а в свойствах объектов просто прописать ссылку на нее.
</p>
```js
var summ = function(a, b) {
      console.log(this.prop + a + b);
    },
    a = {
      prop: 1,
      f: summ
    },
    b = {
      prop: 2,
      f: summ
    };

a.f(1, 1);
b.f(2, 2);
```
<p>
  Как видите, при вызове функций, контекст подставляется динамически и поэтому мы наблюдаем довольно предсказуемое поведение.
</p>
<p>
  Теперь применим метод <strong>call</strong>, но для наглядности, уже к функции summ:
</p>
```js
summ.call(a, 1, 1);
summ.call(b, 2, 2);
```
<p>
  Первым параметром передается контекст, в котором будет выполняться функция, а остальные переданные аргументы передадутся функции. Таким образом, второй аргумент call станет первым аргументом функции и так далее.
</p>
<p>
  Теперь изменим функцию так, чтобы она не выводила в консоль результат, а возвращала его.
</p>
```js
var summ = function(a, b) {
  return this.prop + a + b;
}
```
<p>
  Теперь <strong>summ.call</strong> будет возвращать результат, который мы можем вывести.
</p>
```js
console.log(summ.call(a, 1, 1));
console.log(summ.call(b, 2, 2));
```
<p>Это наглядно демонстрирует работу <strong>call</strong>.</p>

<h3>apply</h3>
<p>
  Она работает точно так же как и <strong>call</strong>, разница только в передаче аргументов в функцию.
</p>
<p>
  Если в <strong>call</strong> мы передавали аргументы напрямую, то в <strong>apply</strong> нужно передавать всего лишь массив с аргументами, а <strong>apply</strong> сама развернет этот массив и передаст аргументы в функцию в нужном порядке.
</p>
```js
console.log(summ.apply(a, [1, 1]));
console.log(summ.apply(b, [2, 2]));
```
<p>
  Как видите, результат не изменился. В <strong>apply</strong> мы передали аргументы для функции в виде массива, а <strong>apply</strong> сама подставила элементы из массива на нужные позиции. Так, первый элемент массива стал первым аргументом функции и тд.
</p>

<p>Теперь выясним чему равен контекст функции, если не вызывать ее из объекта и не применять к ней <strong>bind</strong>, <strong>call</strong> или <strong>apply</strong>.</p>

<h3>Контекст по умолчанию</h3>
<p>Вызовем функцию summ в самом обычном виде</p>
```js
summ(1,1);
```
<p>а внутри функции выведем в консоль this</p>
```js
console.log(this);
```
<p>и запустим скрипт в браузере, для большей наглядности.</p>
<p>Итак, если функции явно не указать контекст, то по умолчанию он равен глобальному объекту. Если запускать скрипт в браузере, то там глобальный объект всегда равен <strong>window</strong>.</p>
<p>Теперь нужно запомнить вот что:</p>
<p><strong>Контекст у функции может быть всего лишь в трех случаях:</strong></p>
<ul>
  <li>
    либо когда мы вызываем функцию из объекта (через точку или квадратные скобки)
  </li>
  <li>
    либо когда используем <strong>bind</strong>, <strong>call</strong> или <strong>apply</strong>
  </li>
  <li>
    или если при вызове функции использовать ключевое слово <strong>new</strong> (разберем позднее)<
    /li>
</ul>
<p>Во всех остальных случаях контекст будет сброшен на глобальный объект.</p>
<p>Вот пример, с которым у разработчиков очень часто возникают затруднения:</p>
```js
var a = {
  prop: 1,
  f: function() {
      var func = function() {
        console.log(this.prop)
      };
      func();
  }
};

a.f();
```

<p>
  Внутри функции f контекст, ясное дело, будет указывать на объект A, а какой будет контекст у функции func?
</p>
<p>
  Вспомним то правило, о котором было сказано ранее:
</p>

<p><strong>Контекст у функции может быть всего лишь в трех случаях:</strong></p>
<ul>
  <li>
    либо когда мы вызываем функцию из объекта (через точку или квадратные скобки)
  </li>
  <li>
    либо когда используем <strong>bind</strong>, <strong>call</strong> или <strong>apply</strong>
  </li>
  <li>
    или если при вызове функции использовать ключевое слово <strong>new</strong> (разберем позднее)<
    /li>
</ul>

<p>
  Функцию func мы вызываем как есть. Не из объекта и не используем <strong>bind</strong>, <strong>call</strong> или <strong>apply</strong>. Следовательно у нее нет контекста, а следовательно <strong>this</strong> будет указывать на <strong>window</strong>, поэтому если мы сейчас запустим скрипт, то увидим <strong>undefined</strong>.
</p>

<p>Почему же с этим примером часто возникает недопонимание?</p>
<p>
  Дело в том, что многие думают, что раз уж мы запускаем функцию из функции, которая имеет контекст, то у этой внутренней функции тоже будет контекст… как бы не так! Сразу вспоминаем то правило!
</p>
<p>
  Решается такая задача очень просто, если вам необходимо передать контекст от основной функции во внутреннюю, то вы либо используете bind, call или apply либо сохраняете контекст в переменную и потом эту переменную используете во внутренней функции
</p>
<p>Разберем оба варианта.</p>
```js
var a = {
  prop: 1,
  f: function() {
      var func = function() {
        console.log(this.prop)
      };
      func.call(this)
  }
};
```
<p>Здесь мы просто, так сказать, пробросили контекст во внутреннюю функцию, думаю здесь не нужно больше пояснений.</p>
<p>И второй вариант:</p>
```js
var a = {
  prop: 1,
  f: function() {
      var that = this;
      
      var func = function() {
        console.log(that.prop)
      };
      
      func()
  }
};
```
<p>Здесь мы просто сохранили текущий контекст функции в переменную и использовали эту переменную внутри вложенной функции.</p>
<p>
  О данном подходе еще иногда говорят - передали контекст через замыкание.
</p>
<p>
  Кстати, если вы используете строгий режим, то контекст по умолчанию будет равер undefined.
</p>
<p>Ну вот мы и разобрались с контекстом.</p>
<p>Осталось рассказать про одну маленькую особенность метода bind.</p>
<h3>bind и аргументы</h3>
<p>
  Если при вызове метода <strong>bind</strong>, передать ему дополнительные аргументы, как в случае с <strong>call</strong>, то <strong>bind</strong> запомнит эти аргументы и при вызове получившейся функции - будет подставлять эти аргументы. Вот так это выглядит:
</p>
```js
var summ = function(a, b) {
  return this.prop + a + b;
};
var newFunc = summ.bind(a, 1, 1);
console.log(newFunc());
```
<p>
  Как видите, мы вызвали новую функцию вообще без параметров. Параметры подставились автоматически, т.к. <strong>bind</strong> запомнил те значения, которые мы ему передали.
</p>
<p>
  Здесь поведение <strong>bind</strong> совпадает с поведением <strong>call</strong>.
</p>
<p>
  Помните, что нельзя изменить контекст у функции, которую вернул bind?
</p>
<p>
  Но если вызывать <strong>bind</strong> повторно на той же самой функции, которую вернул <strong>bind</strong>, то мы получим довольно интересный эффект. Вот как это выглядит:
</p>
<p>
  Если мы вызовем <strong>bind</strong> с одним аргументом
</p>
```js
var newFunc = summ.bind(a, 1);
```
<p>и попробуем вызвать получившуюся функцию, то функция вернет нам <strong>NaN</strong>.</p>
<p>
  Тут всё логично, тк мы передали в функцию summ только один аргумент, а второй аргумент так и остался не определен.
</p>
<p>
  А теперь еще раз вызовем <strong>bind</strong> для полученной ранее функции и снова запустим ее
</p>
```js
var newFunc = summ.bind(a, 1);
newFunc = newFunc.bind(a, 1);
newFunc();
```
<p>
  Как видите, функция summ отработал как положено, как если бы мы передали ей оба аргумента.
</p>
<p>
  Дело в том, что применяя bind над функцией, над которой уже был применен bind, происходит накопление аргументов.
</p>
<p>
  То есть при первом вызове <strong>bind</strong> выставился первый аргумент, а при втором - второй.
</p>
<p>Данную запись можно записать и короче</p>
```js
var newFunc = summ.bind(a, 1).bind(a, 1);
```
<p>
  при втором вызове <strong>bind</strong>, контекст уже не играет роли, т.к., как говорилось ранее, учитывается только тот контекст, который был передан при первом вызове <strong>bind</strong>.
</p>

<h2>ООП</h2>

<p>
  <strong>ООП (объектно-ориентированное программирование)</strong> - это концепция построения системы, в основе которой лежат объекты. То есть вся система разбивается на более мелки части и каждая такая часть является объектом со своим набором методов и свойств.
</p>
<p>
  В ООП существует несколько базовых принципов. Давайте начнем с того, что проведем некоторые аналогии.
</p>
<p>
  Представьте художника, который рисует портрет. Перед художником сидит человек, с которого художник рисует портрет. Каждый человек обладает своими особенностями строения тела или уникальными чертами лица. Задача художника - создать копию этого человека как минимум в единственном экземпляре, скопировав все его особенности. Теперь представьте, что художник нарисовал портрет не в одном экземпляре, а в нескольких, например в 4. Затем художнику захотелось на одном из экземпляров подрисовать человеку усы. Он берет кисть и начинает дорисовывать один из экземпляров. Теперь внимание: то, что художник подрисовал усы одному из экземпляров, не означает, что у оставшихся трех экземпляров тоже нарисовались усы. Это так же не означает, что у человека, с которого человек рисовал портрет, вдруг выросли усы. Логично, не правда ли?
</p>
<p>
  Так вот, переходим от аналогии к коду. Человек сидящий перед художником, это класс, который обладает своими свойствами и особенностями, а несколько портретов, которые художник нарисовал, это экземпляры(объекты) этого класса. Из выше сказанного следует, что экземпляры класса никак не могут повлиять на сам класс. Если мы меняем какие-то свойства экземпляра, то они меняются только внутри этого экземпляра, но не у класса. Примером могут служить те же усы, которые художник дорисовал одному их экземпляров. Так же, меняя свойства одного из экземпляров, мы никак не затрагиваем те же свойства у других экземпляров этого класса.
</p>
<p>
  Теперь давайте разберем, что означает фраза “класс наследует от другого класса”.
</p>
<p>
  Представь того же художника, но теперь он рисует портрет не с человека из первого примера, а с его ребенка.
</p>
<p>
  Логично предположить, что ребенок похож на своих родителей какими-то чертами лица или характера. Но тем не менее, у него есть свои особенности, которые отличают его от родителей. Например: цвет глаз. У родителей - карие, а у их ребенка - голубые.
</p>
<p>
  В случае с классами то же самое: есть класс-родитель, который обладает какими-то свойствами, и есть другой класс, производный от него. Производный класс называют дочерним классом. Дочерний класс наследует все свойства родительского класса и имеет возможность переопределить любое из этих свойств так, как ему нужно.
</p>
<p>
  Опять же аналогия: если ребенок вдруг поранится, это ведь не значит, что автоматически поранятся и его родители. Или, если ребенок научился играть на гитаре, это ведь не значит, что его родители тоже автоматически научились это делать. Следовательно - изменение свойств дочерного класса никак не влияет на свойства родительского. Но не наоборот! Если у одного из родителей, например, есть ямочка на подбородке, то высока вероятность, что у ребенка она будет.
</p>
<p>
  С классами то же самое, наделив родительский класс свойствами, эти свойства будут и у дочернего класса.
</p>
<p>
  В JS нет понятия классов. За то есть понятие <strong>“Конструктор”</strong>.
</p>
<p>
  <strong>Конструктор</strong> - это функция, которая должна создать объект.
</p>

<h2>Конструкторы</h2>

<p>Создадим самую обычную функцию:</p>
```js
var F = function() {};
```
<p>
  Теперь интересный момент - если перед вызовом этой функции поставить ключевое слово new, то функция автоматически вернет новый пустой объект.
</p>
```js
var obj = new F();
console.log(obj);
```
<p>
  Есть еще один интересный момент - <strong>this</strong> внутри этой функции будет равен как раз этому пустому объекту.
</p>
<p>
  Соответственно, внутри функции мы можем выполнять над этим объектом разные манипуляции, например, создавать новые свойства
</p>
```js
var F = function(name) {
  this.name = name;
};

var obj = new F('Сергей');
```

<p>
  Теперь запустим пример и видим, что возвращаемый объект изменился в соответствии с тем, какие манипуляции мы проделали с ним в функции.
</p>
<p>
  И заметьте, что никакого return внутри функции не нужно. При использовании ключевого слова <strong>new</strong>, перед вызовом функции, функция автоматически возвратит новый объект.
</p>
<p>
  Добавим еще один объект и еще один вызов
</p>
```js
var obj  = new F('Сергей'),
    obj2 = new F('Катя');

console.log(obj);
console.log(obj2);
```
<p>
  Запустим пример. Из этого понятно, что каждый раз, при вызове функции с ключевым словом new, возвращается новый объект, со своим набором свойств.
</p>
<p>
  Фактически, внутри этой функции, мы конструируем наш новый объект и поэтому такие функции, носят название “Конструктор”.
</p>

<h3>Свойство constructor</h3>
<p>
  У каждого объекта есть свойство <strong>constructor</strong>, которое указывает на функцию, в которой этот объект был создан.
</p>
<p>
  Выведем свойство <strong>constructor</strong> нашего объекта
</p>
```js
console.log(obj.constructor);
```
<p>
  Как видите, в консоли вывелась та самая функция, которая использовалась для создания данного объекта. То есть свойство constructor содержит ссылку на функцию-конструктор данного объекта.
</p>
<p>
  Таким образом, если у каждого типа данных в JS есть такое свойство и мы можем к нему обратиться.
</p>

<h3>Прототип</h3>
<p>
  Теперь предположим, что мы хотим сконструировать объект так, чтобы у этого объекта был ряд методов… Можно поступить так
</p>
```js
var F = function (name) {
  this.name = name;

  this.setName = function (name) {
    this.name = name;
  };

  this.getName = function () {
    return this.name;
  };
};
```
<p>
  Здесь мы добавляем к конструируемому объекту два новых метода. Первый метод устанавливает новое значение для свойства name, а второй методы возвращает текущее значение свойства <strong>name</strong>.
</p>
<p>
  А вместо <strong>this.name</strong> = name используем метод <strong>setName()</strong>
</p>
<p>
  Вот так можно использовать эти методы в дальнейшем
</p>
```js
var obj = new F('Сергей');

console.log(obj.getName());

obj.setName('Андрей');

console.log(obj.getName());
```
<p>
  Запустим скрипт и увидим, что сначала выводится имя Сергей, так как именно это имя было выставлено при конструировании объекта.
</p>
<p>
  Затем мы устанавливаем свойству name новое значение “Андрей” и выводим его.
</p>
<p>
  Так можно наполнять объект новыми методами.
</p>
<p>
  Но помимо этого способа, есть еще один - наполнять объект методами через свойство prototype у функции-конструктора.
</p>
<p>
  У любой функции-конструктора есть свойство <strong>prototype</strong> и по умолчанию это просто пустой объект
</p>
```js
console.log(F.prototype);
```
<p>
  Но давайте попробуем наполнить этот объект методами, то есть перенесем объявление методов из функции-конструктора в свойство <strong>prototype</strong> этого конструктора
</p>
```js
var F = function (name) {
  this.setName(name);
};

F.prototype.setName = function (name) {
  this.name = name;
};

F.prototype.getName = function () {
  return this.name;
};
```
<p>
  и теперь снова попробуем написать тот же код, что и раньше
</p>
```js
var obj = new F('Сергей');

console.log(obj.getName());

obj.setName('Андрей');

console.log(obj.getName());
```
<p>
  Как видите, результат остался тем же, что и раньше.
</p>
<p>
  Первым делом, когда конструктор конструирует объект, он автоматически добавляет к этому объекту служебное свойство <strong>__proto__</strong>, которое указывает на свойство <strong>prototype</strong> функции-конструктора.
</p>
<p>
  В этом легко убедиться, выполнив следующий код
</p>
```js
console.log(obj.__proto__ === F.prototype);
```
<p>
  Как видите, вывелось <strong>true</strong>
</p>
<p>
  Следовательно, в этом свойстве <strong>__proto__</strong> будет всё то, что мы записывали в <strong>prototype</strong>, ведь это один и тот же объект.
</p>
<p>
  То есть наши методы будут не напрямую в объекте <strong>obj</strong>, а в свойстве <strong>__proto__</strong> внутри него.
</p>
<p>
  Но как же тогда происходит вызов функций?
</p>
<p><strong>Поиск свойств в прототипах</strong></p>
<p>
  Дело в том, что когда мы пытаемся обратиться к какому либо свойству объекта, сначала, это свойство ищется в самом объекте.
</p>
<p>
  Если внутри объекта свойство не было найдено, поиск продолжается в том самом свойстве <strong>__proto__</strong> и так далее.
</p>
<p>
  То есть, вызывая функцию <strong>getName</strong>, сначала интерпретатор ищет ее в самом объекте, и так как функции там нет, то поиск продолжается в свойстве <strong>__proto__</strong> и только там интерпретатор находит эту функцию и выполняет её.
</p>
<p>
  А для разработчика создается впечатление, как будто функция вызывается напрямую из объекта.
</p>
<p>
  Кстати, свойство <strong>constructor</strong> хранится не в самом объекте, а в свойстве <strong>prototype</strong> конструктора… Подумайте над этим...
</p>

<h2>Наследование</h2>
<p>
  Представим, что нам необходимо добавить еще один тип объектов, которые обладали бы теми же методами, что и объекты типа F, но помимо этого, имели бы еще пару дополнительных методов (например методы для установки и чтения возраста), которые были бы не доступы для F
</p>
<p>
  Вот что приходит на ум в первую очередь
</p>
<p>
  Создаем новый конструктор, который, помимо имени, принимает еще и возраст
</p>
```js
var F2 = function(name, age) {};
```
<p>
  Затем копируем прототип из F в F2
</p>
```js
F2.prototype = F.prototype;
```
<p>
  И расширяем прототип у F2 парой новый функций.
</p>
```js
F2.prototype.setAge = function (age) {
  this.age = age;
};

F2.prototype.getAge = function () {
  return this.age;
};
```
<p>
  Таким образом, у F2 теперь есть все методы от F и, плюс ко всему, мы добавили парочку новых
</p>
<p>
  Теперь корректно сконструируем объект типа F2
</p>
```js
var F2 = function(name, age) {
  this.setName(name);
  this.setAge(age);
};
```
<p>Теперь создаем один объект типа F, а второй объект типа F2</p>
```js
var obj = new F('Сергей'),
    obj2 = new F2('Андрей', 30);

console.log(obj.getName());
console.log(obj2.getName(), obj2.getAge());
```
<p>
  Запустим и увидим, что всё работает как надо.
</p>
<p>
  Но всё не совсем так….
</p>
<p>
  Дело в том, что у F тоже появились методы для работы с возрастом. Мы можем в этом убедиться
</p>
```js
obj.setAge(26);
console.log(obj.getName(), obj.getAge());
```
<p>
  Но как же так? Ведь предполагалось, что к методам управления возрастом, будут иметь доступ только объекты типа F2.
</p>
<p>
  Ошибка заключается в том, что мы присвоили прототипу F2 прототип от F
</p>
<p>
  Когда в JS один объект присваивается другому - никакого копирования или клонирования объектов не происходит. Вместо этого, оба объекта указывают на одни и те же данные и изменяя один объект, мы тем самым меняем и другой. Как это и произошло при присваивании
  <strong>prototype</strong>.
</p>
<p>
  Обойти это довольно просто.
</p>

<h3>Правильное наследование</h3>

<p>
  Для этого напишем функцию, которая будет реализовывать правильное
  наследование - создавать между прототипами прослойку из пустого объекта
  таким образом, чтобы изменения в прототипе потомка не влияли на
  родительский прототип.
</p>
<p>
  Вот как это выглядит
</p>
```js
function inherit(child, parent) {
  var Temp = function() {
};

Temp.prototype = parent.prototype;
  child.prototype = new Temp();
}
```
<p>Теперь применим эту функцию</p>
```js
inherit(F2, F);
```
<p>
  То есть наследуем F2 от F
</p>
<p>
  Запускаем старый код и наблюдаем ошибку, в которой сказано, что у объекта obj нет метода <strong>setAge</strong>.
</p>
<p>
  Убрав вызов методов <strong>setAge</strong> и <strong>getAge</strong> из obj1 - ошибка пропадает.
</p>
<p>Отлично! Это то, чего мы и хотели.</p>
<p>
  Теперь давайте наконец посмотрим как работает функция <strong>inherit</strong>. Напомню, что ее задача - создать между прототипом родителя и прототипом наследника прослойку, чтобы изменения в прототипе наследника не влияли на прототип родителя.
</p>
<p>Первым делом мы создаем новый конструктор с именем <strong>Temp</strong></p>
<p>
  Затем прототипом этого конструктора устанавливаем прототип родителя.
</p>
<p>
  Затем в прототип наследника записываем результат работы конструктора.
</p>
<p>
  А теперь давайте вспомним что делает конструктор.
</p>
<p>
  Конструктор создает новый пустой объект, а внутри этого объекта создает служебное свойство <strong>__proto__</strong> которое является копией свойства <strong>prototype</strong> конструктора
</p>
<p>
  Следовательно <strong>new Temp</strong> вернет нам пустой объект со служебным свойством <strong>__proto__</strong> в котором будет прототип родителя.
</p>
<p>
  И этот пустой объект станет прототипом для наследника.
</p>
<p>
  Соответственно, сколько бы мы потом не меняли прототип наследника, это никак не повлияет на прототип родителя, ведь по сути, мы добавляем новые методы в пустой объект.
</p>

<h3>Вызов унаследованных свойств</h3>
<p>Как же тогда из объектов типа F2 вызываются методы, унаследованные от F?</p>
<p>
  А помните, что сначала метод ищется в самом объекте и если не был там найден, ищется в <strong>__proto__</strong>?
</p>
<p>
  Так вот, вызывая obj2.getName произойдет вот что.
</p>
<ul>
  <li>сначала интерпретатор попытается найти <strong>getName</strong> внутри объекта <strong>obj2</strong></li>
  <li>там он его не найдет, после этого, он попытается найти его в свойстве <strong>__proto__</strong> этого объекта, но и там он его не найдет, т.к. там будет два метода для управления возрастом.</li>
  <li>но внутри <strong>__proto__</strong> есть еще одно свойство <strong>__proto__</strong> которое будет указывать уже на прототип конструктора F, в котором и будет метод <strong>getName</strong></li>
</ul>
<p>
  То есть цепочка вызова метода будет вот такая
</p>
```js
obj2.__proto__.__proto__.getName.call(obj2);
```
<p>
  Запустим…. как видите, ничего не изменилось, всё прекрасно работает.
</p>
<p>
  Кстати, <strong>call</strong> мы тут использовали потому, что в такой вариации, вызов метода происходит напрямую из прототипа F
</p>
<p>
  А следовательно и контекст у <strong>getName</strong> будет равняться прототипу F, который является просто набором методов и не имеет свойства
  <strong>name</strong>. Свойство <strong>name</strong> есть только в самом объекте <strong>obj2</strong>. И чтобы переопределить контекст, мы использовали <strong>call</strong>.
</p>
<p>
  Конечно, в здравом уме никто так вызывать функции не будет. Показано это просто для того, чтобы вы четко понимали себе механизм того, как это работает.
</p>
<p>
  В текущей версии JS, всю функцию <strong>inherit</strong> можно сильно укоротить
</p>
```js
function inherit(child, parent) {
  child.prototype = Object.create(parent.prototype);
}
```
<p>
  <strong>Object.create</strong> как раз создает ту самую прослойку на основе переданного прототипа родителя.
</p>
<p>
  Запустим… ничего не изменилось… всё работает как работало.
</p>
<p>
  Теперь предположим, что нам необходимо возможность вызывать одноименные методы родителя… Например мы хотим переопределить поведение метода <strong>setName</strong>.
</p>
<p>
  То есть если вызывать <strong>setName</strong> из объектов типа F он будет вести себя одним образом, а вызывая тот же метод из объектов типа F2, будет вести себя по-другому.
</p>
<p>
  Например, при вызове метода <strong>setName</strong> из F2, мы хотим не просто установить имя, но и вывести уведомление об этом.
</p>
<p>
  Первое, что приходит на ум - просто скопировать код метода <strong>setName</strong> в прототип F2 и немного откорректировать его
</p>
```js
F2.prototype.setName = function (name) {
  this.name = name;
  console.log('имя [', name, '] установлено');
};
```
<p>
  Теперь, если запустить код, то при каждой попытке установить имя для объектов типа F2, мы будем видеть уведомление об этом.
</p>
<p>
  При этом тот же самый метод для объектов типа F ведет себя по-старому.
</p>
<p>
  Казалось бы всё отлично, но есть один нюанс - дублирование кода.
</p>
<p>
  Какая нам разница как работает метод <strong>setName</strong> у родителя?
</p>
<p>
  Мы хотим сохранить поведение родителя, но добавить к нему уведомление.
</p>
<p>
  Соответственно, нам нужно как-то вызвать метод родителя и потом вывести уведомление.
</p>
<p>
  Вместо дублированного кода вызываем метод родителя, но контекст заменим на текущий объект
</p>
```js
F.prototype.setName.call(this, name);
```
<p>
  Думаю не нужно объяснять что тут произошло… про смену контекста уже было сказано достаточно.
</p>
<p>
  Таким образом нам не важно как именно работает метод родителя. Мы просто вызываем его и затем добавляем свое поведение.
</p>
<p>
  А что, если мы не знаем от кого мы унаследовались? Ведь сейчас у нас жестко прописан F и если мы унаследуем F2 от какого-либо другого конструктора, то F придется менять.
</p>
<p>
  Чтобы придать коду больше универсальности, сначала выясним от какого прототипа мы унаследовались, а потом обратимся к нужному методу этого прототипа
</p>
```js
this.__proto__.__proto__.setName.call(this, name);
```
<p>
  <strong>__proto__</strong> это прототип текущего объекта.
</p>
<p>
  Прототипом текущего объект, как вы помните из функции <strong>inherit</strong>, является пустой объект, который был сконструирован при помощи конструктора, прототипом которого является прототип родителя.
</p>

<p>
  Но человек прибывающий в здравом уме тоже не будет писать таким образом вызов родительского метода.
</p>
<p>
  Лучше запомнить где-нибудь конструктор родителя и потом обращаться к нему
</p>
```js
function inherit(child, parent) {
  child.prototype = Object.create(parent.prototype);
  child.parent = parent;
}

F2.parent.prototype.setName.call(this, name);
```
<p>
  Запустим, видим, что ничего не изменилось.
</p>
<p>
  Есть еще более универсальный вариант, при котором нам даже не обязательно знать имя текущего конструктора… мы можем получить его средствами JS
</p>
```js
this.constructor.parent.prototype.setName.call(this, name);
```
<p>
  Но вот ведь незадача… помните, что свойство constructor каждого объекта хранится не в самом объекте, а в прототипе конструктора объекта?
</p>
<p>
  Так вот, когда мы в функции <strong>inherit</strong> записали в свойство prototype объект-прослойку, мы не создали свойство constructor и теперь по правилам поиска свойств в объекте, о которых было сказано выше, свойство
  <strong>constructor</strong> будет найдено только в прототипе родителя.
</p>
<p>
  Соответственно у нас не будет доступа к свойству <strong>constructor</strong> конструктора F2
</p>
<p>
  Чтобы предотвратить это, нам необходимо явно указать конструктор унаследованного объекта в функции <strong>inherit</strong>
</p>
```js
function inherit(child, parent) {
  child.prototype = Object.create(parent.prototype);
  child.prototype.constructor = child;

  child.parent = parent;
}
```
<p>
  Теперь можем запустить и убедиться, что всё работает и ничего не поломалось.
</p>
<p>
  Но и это еще не всё…. есть еще более простой и читаемый способ получить прототип родителя
</p>
```js
function inherit(child, parent) {
  child.prototype = Object.create(parent.prototype);
  child.prototype.constructor = child;
  child.prototype.parent = parent;
}
this.parent.prototype.setName.call(this, name);
```
<p>
  То есть просто записываем конструктор родителя в прототип потомка и всё!
</p>
<p>
  Запустим код и убедимся, что ничего не сломалось
</p>
<p>
  Может возникнуть вопрос: “Зачем нужно было приводить столько разных способов вызова родительских методов, если в итоге мы пришли к простому и лаконичному?”
</p>
<p>
  Это было сделано лишь для того, чтобы вы смогли в деталях понять принцип работы объектов в JS
</p>

<h2>Паттерн “Модуль”</h2>
<p>
  <strong>Модуль</strong> - это такая конструкция, которая позволяет скрывать детали своей внутренней реализации, а открыть только определенные ее части.
</p>
<p>
  Фактически, модуль - это функция, которая возвращает объект с набором методов и эти методы имеют доступ к “внутренностям” той функции через механизм замыканий. И ТОЛЬКО через эти методы можно получить доступ к этим “внутренностям”. Другими словами: модуль позволяет ограничивать видимость своих данных извне (инкапсуляция)
</p>
<p>
  Классический пример - счетчик:
</p>
```js
var Counter = function() {
  var counter = 0;
  return {
    inc: function() {
      counter++;
    },
    dec: function() {
      counter--;
    },
    get: function() {
      return counter;
    }
  }
};

var counter1 = Counter();

counter1.inc();
counter1.inc();
counter1.inc();
counter1.dec();

console.log(counter1.get());
```
<p>
  Объявлена функция <strong>Counter</strong>.
</p>
<p>
  Внутри нее - переменная counter, которой присвоен 0.
</p>
<p>
  Так же, функция <strong>Counter</strong> возвращает объект с тремя методами, для увеличения, уменьшения и получения счетчика.
</p>
<p>
  Все три метода имеют доступ к переменной counter через замыкание.
</p>
<p>
  Возвращая объект с методами, мы, таким образом, скрываем переменную counter от внешнего мира, и доступ к ней имею только методы объекта.
</p>
<p>
  В таких случаях говорят, что переменная counter является приватной, то есть доступной только в пределах <strong>Counter</strong> и получить к ней прямого доступа извне нельзя.
</p>
<p>
  <em>Это и есть паттерн “Модуль”, механизм позволяющий скрывать детали своей реализации.</em>
</p>
<p>Но давайте попробуем наполнить этот объект методами, то есть перенесем объявление методов из функции-конструктора в свойство prototype этого конструктора</p>
```js
function Counter(initial) {
  this.counter = initial
};

Counter.prototype.inc = function () {
  this.counter++
};

Counter.prototype.dec = function () {
  this.counter--
};

function ResetableCounter(initial) {
  Counter.call(this)

  this.initial = initial;
};

ResetableCounter.prototype = Object.create(Counter.prototype)

ResetableCounter.prototype.inc = function () {
  Counter.prototype.inc.call(this);
  console.log("+")
};

ResetableCounter.prototype.dec = function () {
  Counter.prototype.dec.call(this);
  console.log("-")
};

ResetableCounter.prototype.reset = function () {
  this.counter = this.initial
};

let c1 = new Counter(100);
let c2 = new ResetableCounter(100);

c2.inc()
c2.inc()
c2.inc()
c2.inc()
c2.inc()
c2.inc()
c2.dec()
c2.dec()
c2.dec()
c2.reset()

console.log(c1)
console.log(c2)
```
<p>Вариант для ES6</p>
```js
class Counter {
  constructor(initial) {
    this.counter = initial;
  }

  inc() {
    this.counter++;
  }

  dec() {
    this.counter--;
  }
};

class ResetableCounter extends Counter {
  constructor(initial){
    super(initial); // Вызываем конструктор родителя

    this.initial = initial;
  }

  inc() {
    super.inc();
    console.log("+")
  }

  dec() {
    super.dec();
    console.log("-")
  }

  reset() {
    this.counter = this.initial;
    console.log("+-+")
  }
}

let c1 = new Counter(100);
let c2 = new ResetableCounter(100);

c2.inc();
c2.inc();
c2.inc();
c2.inc();
c2.inc();
c2.inc();
c2.dec();
c2.dec();
c2.dec();
c2.reset();

console.log(c1);
console.log(c2);
```
