<h1>ООП</h1>
<h2>this</h2>
<p>Создадим два объекта.</p>
```js
var a = {
  prop: 1,
  f: function() {
    console.log(this.prop);
}
},
b = {
  prop: 2,
  f: function() {
   console.log(this.prop);
  }
};
```
<p>
  Если мы вызовем функцию `f()` у каждого из объектов, мы увидим чему равно значение свойства prop у каждого из объектов:
</p>
<ul>
  <li>`a.f();`</li>
  <li>`b.f();`</li>
</ul>

<p>Теперь более подробно поговорим про <strong>this</strong>. Бытует утверждение, что this указывает на объект, из которого вызывается текущая функция. Это мнение является в корне неверным. <em>this указывает на объект, в контексте которого вызывается   функция.</em>
</p>

<p>
Разница в том, что контекст функции мы можем менять. То есть вызывая функцию `f()` из объекта A, мы можем сделать так, чтобы `this`, внутри этой функции, указывал на объект B. Когда мы вызываем функцию из объекта, контекст этой функции равен тому объекту, из которого мы эту функцию вызываем. Но у каждой функции в JS есть три вспомогательные функции, которые позволяют менять контекст этой функции. Немного запутанно звучит, но на самом деле всё становится понятно, если представить функцию как самый обычный объект, коим функция и является. Так вот у этого объекта есть три метода: <strong>bind</strong>, <strong>call</strong> и <strong>apply</strong>. Эти методы позволяют менять контекст у функции. Пользоваться ими чрезвычайно просто.
</p>

<h2>Смена контекста</h2>
<h3>bind</h3>
<p>
  Bind меняет контекст функции на указанный и возвращает новую функцию, с уже измененным контекстом. Не вызывает указанную функцию, а возвращает новую функцию, с измененным контекстом!
</p>
<p>
  Вот как это работает. Для начала просто сохраним функцию из объекта в переменную
</p>
```js
var newFunc = a.f;
```
<p>Заметьте, мы не вызываем функцию, а просто сохраняем ее в переменную. Это важно.</p>
<p>Теперь вызовем то, что мы только что сохранили.</p>
```js
newFunc(); //выведется undefined
```
<p>
  Всё потому, что функция потеряла свой контекст и теперь `this`, внутри этой функции указывает не на объект A, а на нечто другое, о чем будет рассказано позже.
</p>
<p>
  Но стоит так же отметить, что в переменной newFunc и в объекте A одна и та же функция.
</p>
<p>
  Просто если вызывать ее из объекта А, то контекстом ее является объект А, а если вызывать ее просто, как отдельную часть, то контекста нет. Точнее он есть, но об этом позже.
</p>
<p>Вернемся к функции `bind` и применим ее.</p>
<p>Напомню, что bind возвращает новую функцию с указанным контекстом.</p>
<p>В переменную newFunc запишем результат функции `bind()`</p>
```js
var newFunc = a.f.bind(a);
```
<p>Теперь вызовем то, что получилось.</p>
```js
newFunc();
```
<p>
  Как видите, теперь, даже вызывая функцию без объекта, this внутри этой функции указывает на объект, который мы указали при использовании bind.
</p>
<p>
  Еще более интересный пример: заменим функцию f в объекте A на ту же функцию, но с другим контекстом.
</p>
```js
a.f = a.f.bind(b);

a.f();
b.f();
```

<p>
  Теперь в обоих случаях выводится цифра два. Всё потому, что в первом случае мы заменили контекст на объект B, а во втором, сохранился родной контекст.
</p>
<p>Может возникнуть вопрос: а почему бы просто не сделать так:</p>
```js
a.f = b.f;
```
<p>
  То есть подменить функцию f в объекте A, той же самой функцией, но уже из объекта B, в надежде на то, что this этой функции тоже переедет из объекта в объект.
</p>
<p>
  Тут важно понимать, что мы всего лишь заменили функцию, но как только мы будем вызывать эту функцию из объекта, контекстом этой функции станет тот объект, из которого мы эту функцию вызываем. Но функции для смены контекста позволяют это обойти, ведь применив метод bind, мы можем заменить контекст таким образом, чтобы не имело значения из какого объекта мы вызываем функцию.
</p>
<p>Так же замечу, что изменить контекст мы можем всего один раз. Вот пример:</p>
```js
var newFunc = a.f.bind(b);
newFunc = newFunc.bind(a);
newFunc();
```
<p>
  Как видим, вторая привязка контекста не сработала.
</p>
<p>
  Это не значит, что у нас есть какие-то ограничения по количеству привязок контекста, это всего лишь значит, что у функции, которая получается в результате bind, мы больше не можем менять контекст.
</p>
<p>
  `this` внутри функции - это ее контекст, а не объект из которого мы эту функцию вызываем.
</p>
<p>
  Кстати, в IE, bind доступна начиная с 9 версии. В более ранних версиях, метод bind эмулировался программно.
</p>
<h3>call</h3>
<h3>apply</h3>
