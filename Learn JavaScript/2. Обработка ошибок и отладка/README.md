# Контекст выполнения функции

Контекст выполнения функции — это одно из фундаментальных понятий в JavaScript. Контекстом еще часто называют значение переменной this внутри функции. Также необходимо отметить что понятие «контекст выполнения» и «область видимости» — это не одно и то же.

# Область видимости
**Область видимости** или **(scope)** - определяет доступ к переменным при вызове функции и является уникальной для каждого вызова.

Каждое выполнение функции хранит все переменные в специальном объекте с кодовым именем (scope), который нельзя получить в явном виде, но он есть.

Каждый вызов var - всего лишь создает новое свойство этого объекта, а любое упоминание переменной - первым делом ищется в свойствах этого объекта.

Все изменения локальных переменных являются изменениями свойств этого неявного объекта.

Обычно после того, как функция закончила выполнение, ее область видимости (scope) т.е весь набор локальных переменных убивается.

# this

this — это ссылка на объект, который «вызывает» код в данный момент. Значение this чаще всего определяется тем, как вызывается функция. Когда функция вызывается как метод объекта, переменная this приобретает значение ссылки на объект, который вызывает этот метод:
```js
var user = {
    name: 'John Smith',
    getName: function() {
        console.log(this.name);
    }
};
user.getName(); // John Smith
```

Когда мы вызываем функцию как функцию (не как метод объекта), эта функция будет выполнена в глобальном контексте. Значением переменной this в данном случае будет ссылка на глобальный объект. Однако, если функция вызывается как функция в строгом режиме (strict mode) — значением **this** будет **undefined**.

Контекст выполнения содержит и область видимости, и аргументы функции, и переменную this.

#### Код в JavaScript может быть одного из следующих типов:
|    Виды кода:  |                  Описание                          |
| -------------- |:--------------------------------------------------:|
| eval-код       | код, выполняющийся внутри функции eval()           |
| код функции    | код, выполняющийся в теле функции                  |
| глобальный код | код, не выполняющийся в рамках какой-либо функции  |

Когда интерпретатор JavaScript выполняет код, по умолчанию контекстом выполнения является глобальный контекст. Каждый вызов функции приводит к созданию нового контекста выполнения

```js
// глобальный контекст выполнения
var hello = 'Hello';
var user = function() { // контекст выполнения функции
    var name = 'John Smith';
    
    var getName = function() { // контекст выполнения функции
        return name;
    }
}
```

Каждый раз, когда создается новый контекст выполнения, он добавляется в верхнюю часть стека выполнения. Браузер всегда будет выполнять код в текущем контексте выполнения, который находится на вершине стека выполнения. После завершения, контекст будет удален из верхней части стека и управление вернется к контексту выполнения ниже.

#### Главные моменты:

- Однопоточность — JavaScript работает в однопоточном режиме, т.е. только одна операция может быть выполнена в определенный момент времени.
- Синхронное выполнение кода — код выполняется синхронно, т.е. следующая операция не выполняется до завершения предыдущей.
- Один глобальный контекст выполнения.
- Бесконечное количество контекстов выполнения функции. Каждый вызов функции создает новый контекст выполнения, даже если функция рекурсивно вызывает сама себя.

В интерпретаторе JavaScript каждое создание контекста выполнения происходит в два этапа: этап создания (когда функция только вызвана, но код внутри нее еще не выполняется) и этап выполнения. На этапе создания интерпретатор сначала создает объект переменных (также называемый объект активации), который состоит из всех переменных, объявлений функций и
аргументов, определенных внутри контекста выполнения. Затем инициализируется область видимости, и в последнюю очередь определяется значение переменной this. На этапе выполнения внутренним переменным присваивается значение, код интерпретируется и выполняется.

# Объект Error

Объект Error создается при возникновении ошибки в процессе выполнения сценария и содержит информацию об ошибке, которая используется операторами обработки исключений. Конструктор Error создаёт объект ошибки.

Объект Error также может использоваться в качестве базового для пользовательских исключений.
```js
new Error([message[, fileName[, lineNumber]]])
```

#### Параметры

1. message - Необязательный параметр. Человеко-читаемое описание ошибки.
2. fileName - Необязательный параметр. Значением по умолчанию является имя файла, содержащего код, вызвавший конструктор Error().
3. lineNumber - Необязательный параметр. Значением по умолчанию является номер строки, содержащей вызов конструктора Error().
 
#### Стандартные свойства

- message - описание ошибки. Это свойство содержит краткое описание ошибки. Как правило, это основ-
ной источник информации о произошедшей ошибке

```js
var e = new Error("Произошла проблема");

console.log(e.message); // Произошла проблема
```

- name - название типа ошибки. По умолчанию, объекты класса Error получают значение "Error". Однако,
можно его поменять на другое:
```js
var e = new Error("Malformed input")

console.log(e.name); //выведет Error

e.name = "ParseError"
```

Обычно, **объект Error** создается с намерением возбудить ошибку с помощью ключевого слова throw. Обработка ошибки производится с помощью конструкции **try...catch**:

# throw, try, catch

**Ключевое слово throw** используется для выбрасывания исключения. Ловлей занимается кусок кода, обёрнутый в **блок try**, за которым следует **catch**. Когда код в блоке **try** выкидывает исключение, выполняется блок **catch**. Переменная, указанная в скобках, будет привязана к значению исключения. После завершения выполнения блока **catch**, или же если блок **try** выполняется без проблем, выполнение переходит к коду, лежащему после инструкции **try/catch**.

```js
try {
    throw new Error('Ошибка!');
} catch (e) {
    console.log(e.name + ': ' + e.message); // выведет Error: Ошибка!
}
```

У инструкции try есть ещё одна особенность. За ней может следовать блок **finally**, либо вместо **catch**, либо вместе с **catch**. Блок **finally** означает "выполнить код в любом случае после выполнения блока try". Если функции надо что-то подчистить, то подчищающий код нужно включать в блок **finally**.

```js
try {
    //какой-то код с ошибкой
} catch (e) {
    console.log(e.message);
}
finally {
    console.log('код выполнен');
}
```


```js

function div(a, b) {
  if (b==0) {
    throw new Error("На ноль делить нельзя!")
  }
  return a/b;
}

try {
  let res = div(10, 0);
  console.log(res)
} catch(e) { // Выполняется если есть ошибка
  console.error(e.message);
} finally { // Выполняется в любом случае
  console.log("End");
}

```
# Консоль в Chrome Developer Tools

**Консоль в Chrome Developer Tools** - интерактивный JavaScript-интерпретатор. Консоль дает разработчику доступ к ряду удобных и полезных функций для логирования и отображения ошибок
- console.log()
- console.error()
- console.warn()
- console.info()
- console.debug()

Базовые функции вывода в консоль, позволяют выводить в консоль произвольные сообщения.

Отличаются классификацией выводимых сообщений:
- error() помечает сообщения как ошибки
- warn() помечает сообщения как предупреждения
- debug() помечает сообщения как отладочные

# Маски вывода
| Маски  | Описание                                       |
| ------ |:----------------------------------------------:|
| %s     | выводит значение как строку                    |
| %d, %i | выводит значение как целое число               |
| %f     | выводит значение как число с плавающей запятой |
| %o     | выводит значение как элемент DOM               |
| %0     | выводит значение как объект JavaScript         |
| %c     | применяет к значению заданные CSS стили        |

```js
console.log('%O', document.body);
```

#### console.trace()

Выводит стек вызовов из точки в коде, где был вызван метод. Стек вызовов включает имена файлов и номера строк плюс счетчик вызовов метода trace() из одной и той-же точки.

```js
function f(){
    var a = 1+2;
    console.trace(a)
}
```

#### console.assert()

Функция assert проверяет выражение, переданное первым параметром,
и если выражение ложно, записывает в консоль ошибку вместе со стеком
вызовов:
```js
var two = 3;
var three = 2;
console.assert(two < three, "Два меньше трех")
```

#### console.group() and console.groupEnd();

Функции для группировки вывода. Функция **group()** открывает группу сообщений, в качестве параметра принимает название группы (поддерживается форматирование, как в **console.log()).groupEnd()** закрывает группу

#### console.time() и console.timeEnd()

Функции для вычисления времени исполнения кода. Функция time() запускает таймер, а функция timeEnd() останавливает таймер и выводит его значение. Обе функции принимают название таймера в качестве обязательного параметра.
```js
console.time()
alert('click')
console.timeEnd()
```

# $(), $$() и $x()

Функции, упрощающие выборку элементов, работают только в консоли. **Функция $()** возвращает первый элемент, соответствующий переданному селектору. Вторым параметром можно передать контекст поиска: Функция **$$()** аналогична **$()**, но возвращает все найденные элементы

Функция **$x()** возвращает все элементы, соответствующие выражению **XPath**. Вторым параметром можно передать контекст:

#### $0 — $4

Консоль хранит в памяти ссылки на последние пять элементов, выделенных во вкладке Элементов (Elements). Для доступа к ним используются переменные **$0**, **$1**, **$2**, **$3** и **$4**. **$0** хранит ссылку на текущий выделенный элемент, **$1** — на предыдущий и так далее.

#### $_

Переменная **$_** хранит результат отработки последней команды в консоли. Это позволяет использовать результат выполнения одной команды в другой команде. Попробуйте выполнить эти команды по очереди:

```js
$('body');
$_; //выведет описание элемента body
```

# Точки остановки (Breakpoints)

При разработке веб-приложений регулярно возникает необходимость отлаживать ajax-запросы. Задача усложняется, если ошибка возникает лишь при обращении к определенному URL-адресу. На помощь в этой ситуации приходят точки остановки XHR (XmlHttpRequest). Они останавливают исполнение кода в момент отправки ajax-запроса, позволяя задать URL-адрес либо его часть.

Установить точку остановки XHR можно со вкладки «Sources», нажав на иконку плюсика напротив заголовка «XHR Breakpoints» в правой панели.


Самый простой вариант остановки кода — задать обычную точку остановки. Точка остановки привязывается к строке. Как только интерпретатор JavaScript достигает этой строки, код встает на паузу. В режиме паузы можно посмотреть значения всех переменных, как локальных, так и глобальных, а также исполнять код пошагово.

Также в режиме паузы работает консоль, более того, в консоли доступен контекст функции, в которой остановлен код. Это очень удобно, ведь можно, не отключая паузу, отладить код, избегая зацикливания на внесении изменений, сохранении и перезагрузке страницы.

#### Условные точки остановки (Conditional breakpoints)

Точки остановки, несомненно, очень полезный инструмент, но часто строка кода исполняется тысячи раз, а с точки зрения отладки интересна лишь при определенных условиях. В такой ситуации на помощь приходят условные точки остановки.

Чтобы создать условную точку остановки, нужно кликнуть правой кнопкой мышки по номеру строки, выбрать «Add conditional breakpoint…» и ввести выражение. Если в момент исполнения кода выражение истинно, исполнение будет приостановлено.

# Точки остановки DOM (DOM Breakpoints)

Часто бывают ситуации, когда какой-то скрипт модифицирует элемент на странице или его содержимое, но идентифицировать обидчика не получается. Для таких случаев в Chrome Developer Tools предусмотрены точки остановки DOM. Они позволяют приостановить исполнение кода в случае изменения атрибутов элемента («Attributes modifications»), изменений в дереве
дочерних элементов («Subtree modifications») либо удаления элемента («Node removal»).

# Условные точки остановки (Conditional breakpoints)

Точки остановки, несомненно, очень полезный инструмент, но часто строка кода исполняется тысячи раз, а с точки зрения отладки интересна лишь при определенных условиях. В такой ситуации на помощь приходят условные точки остановки. Чтобы создать условную точку остановки, нужно кликнуть правой кнопкой мышки по номеру строки, выбрать «Add conditional breakpoint…» и ввести выражение. Если в момент исполнения кода выражение истинно, исполнение будет приостановлено.

# Точки остановки DOM (DOM Breakpoints)

Часто бывают ситуации, когда какой-то скрипт модифицирует элемент на странице или его содержимое, но идентифицировать обидчика не получается. Для таких случаев в Chrome Developer Tools предусмотрены точки остановки DOM. Они позволяют приостановить исполнение кода в случае изменения атрибутов элемента («Attributes modifications»), изменений в дереве дочерних элементов («Subtree modifications») либо удаления элемента («Node removal»). Для создания точки остановки DOM необходимо найти элемент во вкладке «Elements», щелкнуть его правой кнопкой мыши и в открывшемся меню выбрать пункт «Break on…».


# Точки остановки XHR (XHR Breakpoints)

При разработке веб-приложений регулярно возникает необходимость отлаживать ajax-запросы. Задача усложняется, если ошибка возникает лишь
при обращении к определенному URL-адресу. На помощь в этой ситуации приходят точки остановки XHR (XmlHttpRequest). Они останавливают исполнение кода в момент отправки ajax-запроса, позволяя задать URL-адрес либо его часть. Установить точку остановки XHR можно со вкладки «Sources», нажав на иконку плюсика напротив заголовка «XHR Breakpoints» в правой панели.

# Точки остановки по событиям (Event Listener Breakpoints)

Допустим, один из скриптов где-то создает обработчик событий, и необходимо его найти, зная лишь название события. Для этого идеально подойдет точка остановки по событиям. Chrome Developer Tools позволяет установить точку остановки как на конкретное событие (например click или keypress), так и на целую группу событий (например «Mouse» или «Keyboard»). Чтобы установить точку остановки по событиям, нужно перейти во вкладку «Sources» и в правой панели под заголовком «Event Listener Breakpoints» выбрать интересующие события.

# Оператор debugger;

Когда браузер достигает строчки debugger; в любом коде, он автоматически останавливает выполнение скрипта в этой точке и переходит на вкладку Скриптов (Sources).
